% Template for ICIP-2012 paper; to be used with:
%          spconf.sty  - ICASSP/ICIP LaTeX style file, and
%          IEEEbib.bst - IEEE bibliography style file.
% --------------------------------------------------------------------------
\documentclass{article}
\usepackage{spconf,amsmath,graphicx,minted}

% Example definitions.
% --------------------
\def\x{{\mathbf x}}
\def\L{{\cal L}}

% Title.
% ------
\title{OpenDcd: Open Source WFST Decoding Toolkit}
%
% Single address.
% ---------------
%\name{Author(s) Name(s)}
%\address{Yandex LLC}
%
% For example:
% ------------
%\address{School\\
%	Department\\
%	Address}
%
% Two addresses (uncomment and modify for two-address case).
% ----------------------------------------------------------
%\twoauthors
%  {A. Author-one, B. Author-two\sthanks{Thanks to XYZ agency for funding.}}
%	{School A-B\\
%	Department A-B\\
%	Address A-B}
%  {C. Author-three, D. Author-four\sthanks{The fourth author performed the work
%	while at ...}}
%	{School C-D\\
%	Department C-D\\
%	Address C-D}
%
\begin{document}
%\ninept
%
\maketitle
%
\begin{abstract}
In this paper we introduce \emph{OpenDcd} a lightweight and portable Weighted Finite State
Transducer based speech decoding toolkit. OpenDcd is a collection or tools for speech
recognition decoding, cascade construction and related conversion and results manipulation.
The toolkit is faster and requires substantially less memory than other open source alternatives.
\end{abstract}
%
\begin{keywords}
WFST, Decoding, Speech recognition, Open source
\end{keywords}
%
\section{Introduction}
\label{sec:intro}
Open source and reproducible results are speech recognition are an essential
part of modern science. Recently, there has become available many excellent
tools for manipulating automata, building language models, all the way up
build sophisticated speech recognitions system.  However, the state of modern 
decoding libraries is still lagging. In this paper we describe the OpenDcd
release a set of tools under active development for constructing and decoding
finite state speech recognition cascades. The toolkit makes use of OpenFst for the 
underlying finite state representations
and operations, and the OpenGRM~\cite{roark12} for language model conversion.

One extremely important feature of the toolkit is it can be built as 
The toolkit can be built as standalone decoder with no dependencies, or as addon
with Kaldi. For the latter there is full access to all of the IO mechanism and 
acoustic models available in Kaldi. In later sections we discuss the lattice generation
mechanisms that make it possible to use the OpenDcd in many of Kaldi's training and
rescoring pipelines. 

Furthermore the modular nature of OpenDcd's  design allow for new types of 
acoustic model for example LSTM or RNN to plugged into the decoder. 

The library started off as an internal project for research use we are
releasing the project under an open source licence. One design goal was 
to allow for customization via \texttt{C++} templates.

\section{Introduction}
\label{sec:format}
There are several components in the system. The cascade tools, the decoder core
and the results post-processing tools.

\section{Decoder Core}
\label{sec:decodercore}

\subsection{Customization}
\label{sec:custom}
The core of the decoder is the \texttt{ArcDecoder} class that is parametrized on a transition
model, Fst  and lattice.
\begin{minted}[mathescape,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{cpp}
  template<class T, class F, class L>
  class ArcDecoder;
\end{minted}

For example the following code in Kaldi mode will create a decoder that uses
cascade in the tropical semiring, has HMM transition model with GMM state 
output distributions and generates lattice.

\begin{minted}[mathescape,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{cpp}
  typedef HMMTransitionModel<GMMDecodable> TransModel;
  ArcDecoder<StdFst, TransModel, ApproxLattice> Decoder;
\end{minted}





\subsection{Lattice Generation}
The decoder supports lattice generation based on the \emph{phone-pair}
approximation and a \emph{full} lattice generation strategy.
%\url{https://code.google.com/p/shinyprofiler/}

\section{Instrumentation and Logging}
\label{sec:instrumentation}
The decoder has several built analysis mechanism, these are the call analyzer,
memory analyzer and the search space analyzer. For fined grained analysis we 
make use of the ShinyProfiler which generate very detailed call graphs.

\section{Cascade Tools}
\label{sec:cascade}
The toolkit includes a very fast build procedure for constructing a recognition
\emph{cascade} from a language, lexicon and context-dependency models. In 
machine translation experimental pipelines have become more popular~\cite{koehn10}. 
However, most of these are very similar to well known Unix make tool. We make 
use of \texttt{make} as our basic tool to track the components. 
If a compoenent in the cascade is modified make we only rebuild.

The FST framework provides many operations for combining and manipulating
automata. To construct a speech recognition cascade and recognize speech 
typically requires three core operations: Composition, Determinization and
Shortestpath. The later is handled be the decoder command and by careful
component construction. We 

The ngram model uses the direct minimalistic construction proposed by
Caseiro~\cite{caseiro01} and implemented by OpenGRM.

\section{Post-processing Tools}
\label{sec:postprocess}

\section{Kaldi Interop}
With recent importance of Kaldi with provide two levels of compatability.
When the decoder is built for standalone operation we provide native reading
of Kaldi features and writing for alignment formats.


\section{Evaluations}
\label{sec:majhead}

\subsection{Wall Street Journal}

\section{Summary}
\label{sec:page}
In this paper we have described OpenDcd a toolkit. In other papers we intend to
describe the algoritms and cusomization in more depth. In future release we
plan to release one-pass neural network re-scoring.

\bibliographystyle{IEEEbib}
\bibliography{WFSTSpeech}

\end{document}


The DCD Library is a software collection for speech recognition decoding and
related functions. Based on the Finite-State Machine (FSM) Library, it provides
higher-level operations needed specifically for decoding. These include
algorithms that:

make an optimized recognition transducer (``network'') from a grammar, a
lexicon, and a context-dependency specification search a recognition transducer
to find the best matching path or a set of paths (``lattice''), given an input
utterance and an acoustic model weight lattices with just their grammatical and
acoustic components align reference and hypothesis automata using edit
distances (``scoring'') This library is not intended to provide a complete
speech recognition system: there is no acoustic model, no acoustic feature
generator (``front-end''), and no acoustic, lexical or grammatical training
provided by this package; all are considered outside the scope of this library.
It does provide a general, extensible acoustic model interface, it accepts
general context-dependency, lexical and grammatical models encoded as
finite-state transducers, and it reads pre-computed acoustic features in a
variety of formats. Our emphasis is on the generality, flexibility and
performance of the operations provided here, which are to be used as key
algorithmic components of an automatic speech recognition (ASR) system. Several
of the general operations should also find application outside of speech
recognition.  There is a program-level set of executables that is meant for use
in ``batch'' speech recognition training and testing. There is a C++
library-level set of routines that is meant for easy integration into an ASR
system. The components are quite modular and independent, so the user can
select which functionality they require.
